syntax = "proto2";

// Sugar for easier handling in Java
option java_package = "com.shapeshift.keepkey.lib.protobuf";
option java_outer_classname = "TrezorMessageEos";

/**
 * Request: Ask device for Eos public key corresponding to address_n path
 * @start
 * @next EosPublicKey
 * @next Failure
 */
message EosGetPublicKey {
    repeated uint32 address_n = 1;  // BIP-32 path to derive the key from master node 44'/194'/0'
    optional bool show_display = 2; // optionally show on display before sending the result
}

/**
 * Response: Contains an Eos public key derived from device private seed
 * @end
 */
message EosPublicKey {
    optional string public_key = 1;     // EOS pub key in Base58 encoding
}

/**
 * Request: Ask device to sign transaction
 * @start
 * @next EosTxRequest
 * @next Failure
 */
 message EosSignTx {
    repeated uint32 address_n = 1;                // BIP-32 path to derive the key from master node 44'/194'/0'
    optional bytes chain_id = 2;                  // 256-bit long chain id
    optional EosTxHeader header = 3;              // EOS transaction header
    optional uint32 num_actions = 4;              // number of actions 
}

/**
* Structure representing EOS transaction header
*/
message EosTxHeader {
    required uint32 expiration = 1;           // time at which transaction expires
    required uint32 ref_block_num = 2;        // 16-bit specifies a block num in the last 2^16 blocks.
    required uint32 ref_block_prefix = 3;     // specifies the lower 32 bits of the blockid at get_ref_blocknum
    required uint32 max_net_usage_words = 4;  // upper limit on total network bandwidth (in 8 byte words) billed for this transaction
    required uint32 max_cpu_usage_ms = 5;     // 8-bit upper limit on the total CPU time billed for this transaction
    required uint32 delay_sec = 6;            // number of seconds to delay this transaction for during which it may be canceled.
}

/**
 * Response: Device asks to upload next action
 * @next EosTxActionAck
 */
message EosTxActionRequest {
}

/**
 * Request: Next action data that needs to be uploaded
 * @next EosTxActionRequest
 * @next EosSignedTx
 * @next Failure
 */
message EosTxActionAck {
    optional EosActionCommon common = 1;
    optional EosActionTransfer transfer = 2;
    optional EosActionDelegate delegate = 3;
    optional EosActionUndelegate undelegate = 4;
    optional EosActionBuyRam buy_ram = 5;
    optional EosActionBuyRamBytes buy_ram_bytes = 6;
    optional EosActionSellRam sell_ram = 7;
    optional EosActionVoteProducer vote_producer = 8;
}

/**
* Structure representing asset type
*/
message EosAsset {
    optional sint64 amount = 1;
    optional uint64 symbol = 2;           // First 8-bits used for precission.    
}

/**
* Structure representing action permission level
*/
message EosPermissionLevel {
    optional uint64 actor = 1;
    optional uint64 permission = 2;
}

/**
* Structure representing the common part of every action
*/
message EosActionCommon {
    optional uint64 account = 1;          // Contract name
    optional uint64 name = 2;             // Action name
    repeated EosPermissionLevel authorization = 3;
}

/**
* Structure representing transfer data structure
*/
message EosActionTransfer {
    optional uint64 from = 1;             // Asset sender
    optional uint64 to = 2;
    optional EosAsset quantity = 3;
    optional string memo = 4;
}

/**
* Structure representing delegation data structure
*/
message EosActionDelegate {
    optional uint64 from = 1;
    optional uint64 receiver = 2;
    optional EosAsset net_quantity = 3;    // Asset format '1.0000 EOS'
    optional EosAsset cpu_quantity = 4;    // Asset format '1.0000 EOS'
    optional bool transfer = 5;            // Transfer delegated tokens or not.
}

/**
* Structure representing the removal of delegated resources from `from`
*/
message EosActionUndelegate {
    optional uint64 from = 1;
    optional uint64 receiver = 2;
    optional EosAsset net_quantity = 3;   // Asset format '1.0000 EOS'
    optional EosAsset cpu_quantity = 4;   // Asset format '1.0000 EOS'
}

/**
* Structure representing buying RAM operation for EOS tokens
*/
message EosActionBuyRam {        
    optional uint64 payer = 1;
    optional uint64 receiver = 2;
    optional EosAsset quantity = 3;   // Asset format '1.0000 EOS'
}

/** 
* Structure representing buying bytes according to RAM market price.
*/
message EosActionBuyRamBytes {
    optional uint64 payer = 1;
    optional uint64 receiver = 2;
    optional uint32 bytes = 3;       // Number of bytes
}

/** 
* Structure representing sell RAM
*/
message EosActionSellRam {
    optional uint64 account = 1;
    optional sint64 bytes = 2;       // Number of bytes
}

/** 
* Structure representing voting. Currently, there could be up to 30 producers.
*/
message EosActionVoteProducer {
    optional uint64 voter = 1;       // Voter account
    optional uint64 proxy = 2;       // Proxy voter account
    repeated uint64 producers = 3;   // List of producers
}

/**
 * Response: Device returns the signature.
 * The signature_* fields contain the computed transaction signature. All three fields will be present.
 * @end
 */
message EosSignedTx {
    optional uint32 signature_v = 1;    // Computed signature (recovery parameter, limited to 31 or 32)
    optional bytes signature_r = 2;     // Computed signature R component (256 bit)
    optional bytes signature_s = 3;     // Computed signature S component (256 bit)
}
